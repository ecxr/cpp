/*
 * MST: Minimum Spanning Tree
 * Author: (@)
 */

/*
#include <vector>

using namepsace std;

class MST
{
    // Given a graph G, with edges E of the form (v1, v2) and vertices V
    // dist: array of distances from the source to each vertext
    // edges: array indicating, for a given vertex, which vertex in the tre it:
    //   is closest to
    //   i: loop index
    // MST: list of finished vertices
    // U: list or heap of unfinished vertices
    // Initialization: set every distance to INFINITY until we discover
    //                 a way to link a vertex to the spanning tree
    // for i = 0 to |V| -1
    //     dist[i] = INFINITY
    //     edge[i] = NULL
    // end
    // pick a vertex, s - say vertex 0
    // dist[s] = 0
    // while (MST is missing a vertex)
    //     pick the vertex, v, in U with the shortest edge to the group of vertices
    //                                       ^- Priority Queue
    //     in the spanning tree and add it to the MST
    //   for each edge of v, (v1, v2)
    //       if (length(v1, v2) < dist[v2])
    //           dist[v2] = length(v1, v2)
    //           edges[v2] = v1
    //           possibly update U, depending on the implementation
    //       end if
    //   end for
    // end while

    // Notes: Do we still want duplicate edges? (order of to/from doesnt matter, and we are undirected)
    //        Storing v to w as e1 and w to v as e2 is almost a directed graph?
    //        Need a priority queue of edge weights.

};
*/
